# 1주차_웹 기초 교육

## Web이란?
World Wide Web이란 인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간을 의미
<br></br>
간단히 줄여 WWW나 W3라고도 부르며, 간단히 웹(Web)이라고 많이 불림

## Web의 특징
웹은 인터넷 상에서 텍스트나 그림, 소리, 영상 등과 같은 멀티미디어정보를 **하이퍼텍스트** 방식으로 제공
<br></br>
**하이퍼텍스트(hypertext)** 란 문서 내부에 또 다른 문서로 연결되는 참조를 집어 넣음으로써 웹 상에 존재하는 여러 문서끼리 서로 참조할 수 있는 기술을 의미
<br></br>
웹에서는 HTML이라는 언어를 사용하여 누구나 자신만의 문서를 작성할 수 있음
<br></br>
또한, 이렇게 작성된 웹상의 문서에는 HTTP라는 프로토콜을 사용하면 누구나 검색하고 접근할 수 있음
<br></br>
## Web의 구성
- 웹 페이지(Web page) : 웹에서는 HTML 언어를 사용하여 작성된 하이퍼텍스트 문서
<br></br>
- 웹 사이트(Web site) : 웹 페이지들 중에서 서로 관련된 내용으로 작성된 웹 피이지들의 집합
<br></br>
- 웹 서핑(Web surfing) : 사용자가 웹 페이제이 포함된 하이퍼링크를 따라 다른 웹 페이지들로 계속하여 이동하는 것
<br></br>
- 웹 브라우저(Web browser) : 사용자가 웹 페이지를 검색하기 위해 사용하는 프로그램
<br></br>
## Web Server란?
**"웹 서버"는 하드웨어, 소프트웨어 혹은 두 개가 같이 동작하는 것을 의미**<br></br>
- 하드웨어 측면 : 웹 서버의 소프트웨어와 웹 사이트의 컴포넌트 파일들을 저장하는 컴퓨터<br></br>
- 소프트웨어 측면 : 웹 서버는 기본적으로 웹 사용자가 어떻게 호스트 파일들에 접근하지는 관리함. 이 문서에서 웹 서버는 HTTP서버로 국한함. HTTP 서버는 URL(Web addresses)와 HTTP의 소프트웨어 일부임
<br></br>

브라우저가 웹 서버에 불려진 파일을 필요로 할 때, 브라우저는 HTTP를 통해 파일을 요청 -> 요청이 올바른 웹 서버(하드웨어)에 도달했을 때, HTTP서버(소프트웨어)는 요청된 문서를 HTTP를 이용해 보내줌<br></br>
웹 서버는 HTTP를 사용하여 HTML 파일과 다른 컴포넌트 파일들을 저장 및 전송함
<br></br>
**정적 웹 서버** : HTTP 서버(소프트웨어)가 있는 컴퓨터(하드웨어)
**동적 웹 서버** : 추가적인 서프트웨어(대부분 일반적인 애플리케이션 서버와 데이터베이스)로 구성

## HTTP란?
**HTTP(HyperText Transfer Protocol)**
텍스트 기반의 통신 규약으로 인터넷에서 데이터를 주고받을 수 있는 프로토콜
<br></br>
## HTTP 동작
사용자(client)가 부라우저를 통해서 어떠한 서비르르 url을 통하거나 다른 것을 통해서 요청(request)을 하면 해단 요청사항에 맞는 결과를 찾아서 사용자에게 응답(response)하는 형태
- 요청 : client -> server
- 응답 : server -> client
<br></br>
## HTTP 특징
HTTP 메시지는 HTTP 서버와 클라이언트에 의해 해석됨
<br></br>
**TCP/IP**를 이용하는 프로토콜<br>
- TCP/IP란?
  - TCP(Transmission Control Protocol)
    - 두 개의 호스트를 연결하고 데이터 스트림(data stream)을 교환하게 해주는 네트워크 프로토콜
    - 데이터 패킷에 일련의 번호를 부여함으로써, 데이터 손실을 찾아내 교정하고, 순서를 재조합하여 클라이언트에게 전달
    - 신뢰성이 높음
  - IP(Internet Protocol)
    - 4byte로 이루어진 컴퓨터의 주소이며, 255.255.255.255와 같이 표시
    - 컴퓨터와 컴퓨터간의 데이터를 전송하기 위해서는 각 컴퓨터의 주소가 필요
    - IP주소는 하드웨어 고유의 식별번호인 MAC주소와 다르게 임시적으로 다른 주체에게 받는 주소이므로 바뀔 수 있음

<br></br>
요청을 주고 받을 때만 연결을 유지하고 응답을 주고나면 TCP/IP 연결을 끊는**비 연결성 프로토콜**이므로 요청/응답 방식으로 동작
<br></br>
## Auth
**인증(Authentication)** 이란 유저의 identification을 확인하는 절차<br>
e.g) 회원가입, 로그인
<br></br>
인증방법에는 session/cookie, token기반 인증 방식 등이 있다.
<br></br>
## Session/Cookie
### **인증 절차**
1. 사용자가 로그인을 요청
2. 서버에서는 계정 정보를 읽어 사용자를 확인 후, 사용자의 고유 ID 값을 부여한 후 세션 저장소에 저장하고, 이와 연결되는 세션 ID 를 발행
3. 클라이언트는 서버에서 해당 세션 ID 를 받아 쿠키에 저장 한 후, 인증이 필요한 요청마다 쿠키를 헤더에 추가하여 보냄
4. 서버에서는 쿠키를 받아 세션 저장소에서 확인 한 후, 일치하는 정보를 가져옴
5. 인증이 완료되고 서버는 사용자에 맞는 데이터를 보냄


<br></br>
![Bumblebee_study](image/session%20process.png)

### **Cookie**
서버에서 발급된 세션을 열기 위한 key 값(=세션 ID)
- 웹 서버가 웹 브라우저에 보내 저장했다가 서버의 부가적인 요청이 있을 때 다시 서버로 보내주는 문자열 정보
- 웹 페이지 방문 시 방문 기록 등 브라우저에서의 정보들이 저장된 텍스트 파일
- 웹에서 요청마다 매번 연결과 해제가 되면서 요청마다 새로운 사용자로 인식됨
- 데이터 형태는 key, value 형태로 String문이며 4KB 이상 저장 불가

### **Session**
서버에서 가지고 있는 정보
- 클라이언트와 서버 간의 연결 상태
- 각 클라이언트의 고유 세션 ID를 부여
- 세션을 관리하기 위한 세션 DB가 있음
- 저장 공간의 용량 문제
  - 세션은 서버의 메모리 내부에 저장되는데, 유저가 많은 대형 서비스에서는 세션의 양이 많아지는 만큼 메모리 부하가 발생
- 확장성의 문제
  - 서비스의 규모가 커져 서버를 여러 대로 확장 및 분산해야 한다면 세션을 분산시키는 기술을 따로 설계해야 함


<br></br>
### **Cookie와 Session의 차이**
<br>

|구분|Cookie|Session|
|---|---|---|
|저장 위치|client(local)|Server|
|life Cycle<br>(만료 시점)|쿠키 저장 시 설정(브라우저가 종료되더라도 만료시점이 지나지 않으면 자동삭제되지 않음)|브라우저 종료 시 삭제(기간 별도 지정 가능)|
|보안|로컬에 저장되어 탈취, 변조 위험 존재<br> 비교적 취약|서버에 저장되므로 안전함|
|속도|빠름|제공받은 세션ID를 이용해서 서버에서 다시 데이터를 참조해야 하므로 비교적 느림|

## JWT Token
브라우저에서만 사용할 수 있는 쿠키와 달리, 토큰은 서버에 보낼 수 있음
- JWT(JSON Web Token)은 인증에 필요한 정보들을 암호화시킨 토큰
- session/cookie 방식과 유사하게 사용자는 **Access Token**을 HTTP 헤더에 실어 서버에 전송

### **토큰의 구조**
- Header : 토큰의 종류와 SIGNATURE 생성을 위해서 어떤 알고리즘을 사용했는지 명시
- Payload : 내가 로그인한 유저임을 증명할 수 있는 기본적인 정보로 차후에 클라이언트가 다시 토큰을 보내면 해독해서 DB내의 유저 정보와 비교
- Signature : 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드. 서명은 위에서 만든 헤더와 페이로드의 값을 각각 BASE64로 인코딩하고, 인코딩한 값을 내가 설정한 비밀키를 이용해 헤더에서 정의한 알고리즘(여기서는 HS256)으로 해싱을 하고, 이 값을 다시 BASE64로 인코딩하여 생성함. 혹시라도 토큰이 제 3자에 의해 탈취되어서 페이로드의 내용이 변경된다면 토큰의 값이 크게 변경됨<br></br>

![Bumblebee_study](/image/jwt.png)
<br></br>
### **인증 절차**
1. 사용자가 로그인 요청
2. 서버에서는 계정 정보를 읽어 사용자를 확인 후, 사용자의 고유 ID 값을 부여한 후 기타 정보와 함께 Payload에 집어넣음
3. JWT 토큰의 유효기간을 설정
4. 암호화할 Secret key 를 이용해 Access Token 을 발급
5. 사용자는 Access Token 을 받아 저장 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보냄
6. 서버에서는 해당 토큰의 Verify Signature 를 Secret key 로 복호화한 후, 조작 여부, 유효기간 확인
7. 검증이 완료되었을 경우, Payload 를 디코딩 하여 사용자의 ID 에 맞는 데이터를 가져옴

### **장점**
1. **간편하다**
    | 세션/쿠키 인증은 별도의 저장소 관리가 필요함. 그에 비해
JWT 는 발급한 후 검증만 하기 때문에 추가 저장소가 필요하지 않음. (StateLess - 상태/정보 저장하지 않음) 이는 서버를 확장하거나 유지, 보수하는데 유리합니다.
1. **확장성이 뛰어나다** | 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능
Facebook, Google, Microsoft 로그인 등은 모두 토큰 기반으로 인증을 하는데, 권한을 받을 수도, 프로필을 써드파티 웹사이트에 제공하도록 허가 할 수도 있음
<br></br>
### **단점**
1. **이미 발급된 JWT에 대해서는 유효기간이 완료될 때까지는 계속 사용이 가능함** | 세션/쿠키 인증 방식은 쿠키가 악의적으로 이용될 경우 쿠키를 삭제하면 됨.
그러나 JWT는 유효기간이 지나기 전까지 정보들을 이용할 수 있음.
이에 대한 해결책은, Access Token 유효기간을 짧게 하고 Refresh Token 이라는 새로운 토큰을 발급함. 그렇게 되면 Access Token을 탈취당해도 상대적으로 피해를 줄일 수 있음
2. **Payload 정보가 제한적임** | Payload는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있음. 따라서 유저의 중요한 정보들은 Payload에 넣을 수 없음.
3. **JWT의 길이** | JWT 의 길이는 길기 때문에 인증이 필요한 요청이 많아질수록 서버의 자원낭비가 발생